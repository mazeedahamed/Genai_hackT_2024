# Transitive fuzzy grouping with detailed debug logging
import pandas as pd
from rapidfuzz import fuzz
from collections import defaultdict, deque

# Load all sheets
excel_file = "your_file.xlsx"  # Replace with actual file
sheets = pd.read_excel(excel_file, sheet_name=None)

# Choose sheet to group
sheet_to_group = "Sheet1"  # Change if needed
df = sheets[sheet_to_group]

# Parameters
SIMILARITY_THRESHOLD = 80

# Prepare output columns
df['group_name'] = None
df['group_number'] = None
df['score'] = None

# Process each Account no group
for account_no, account_group in df.groupby('Account no'):
    print(f"\nProcessing Account no: {account_no}")

    account_group_nonblank = account_group[account_group['Party name'].notna() & (account_group['Party name'].str.strip() != '')]
    party_names = account_group_nonblank['Party name'].str.strip().tolist()
    num_parties = len(party_names)

    print("Party Names:", party_names)

    if num_parties == 0:
        continue

    # Step 1: Build similarity graph
    graph = defaultdict(set)
    for i in range(num_parties):
        for j in range(i + 1, num_parties):
            score = fuzz.token_set_ratio(party_names[i], party_names[j])
            print(f"Similarity between '{party_names[i]}' and '{party_names[j]}' = {score}")
            if score >= SIMILARITY_THRESHOLD:
                graph[i].add(j)
                graph[j].add(i)

    # Step 2: Find connected components
    visited = [False] * num_parties
    unique_groups = []

    for i in range(num_parties):
        if not visited[i]:
            queue = deque([i])
            group = []
            while queue:
                node = queue.popleft()
                if not visited[node]:
                    visited[node] = True
                    group.append(node)
                    queue.extend(graph[node])
            unique_groups.append(group)

    # Step 3: Assign group name and update df
    for group_number, group_indices in enumerate(unique_groups, start=1):
        group_parties = [party_names[i] for i in group_indices]

        # Determine best group name
        best_match_count = -1
        group_name = group_parties[0]
        for candidate in group_parties:
            match_count = sum(
                1 for other in group_parties if candidate != other and fuzz.token_set_ratio(candidate, other) >= SIMILARITY_THRESHOLD
            )
            print(f"      Candidate '{candidate}' matched with {match_count} others")
            if match_count > best_match_count:
                best_match_count = match_count
                group_name = candidate

        print(f"  ✅ Final Group {group_number} name: '{group_name}'")

        for i in group_indices:
            name = party_names[i]
            row_index = account_group_nonblank.index[i]
            score = 100 if name == group_name else fuzz.token_set_ratio(name, group_name)
            print(f"      Assigning '{name}' to group {group_number} with score {score}")
            df.loc[row_index, 'group_name'] = group_name
            df.loc[row_index, 'group_number'] = group_number
            df.loc[row_index, 'score'] = score

# Summary sheet
summary_df = df[['Account no', 'group_number']].drop_duplicates()
group_counts = summary_df.groupby('Account no')['group_number'].nunique().reset_index()
group_counts.columns = ['Account no', 'number_of_groups']

# Update sheets
sheets[sheet_to_group] = df
sheets['Group Summary'] = group_counts

# Save output
output_file = "grouped_output_with_all_sheets.xlsx"
with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
    for sheet_name, sheet_df in sheets.items():
        sheet_df.to_excel(writer, sheet_name=sheet_name, index=False)

print(f"\n✅ Saved grouped output to {output_file}")



 # Filter only those directly similar to group_name
    filtered_indices = []
    for i in group_indices:
        name = party_names[i]
        score = fuzz.token_set_ratio(name, group_name)
        if score >= SIMILARITY_THRESHOLD:
            filtered_indices.append(i)
        else:
            print(f"  ❌ '{name}' removed from group {group_number} due to low direct match ({score}) with '{group_name}'")

    # Assign only filtered rows to group
    for i in filtered_indices:
        name = party_names[i]
        row_index = account_group_nonblank.index[i]
        score = 100 if name == group_name else fuzz.token_set_ratio(name, group_name)
        print(f"      Assigning '{name}' to group {group_number} with score {score}")
        df.loc[row_index, 'group_name'] = group_name
        df.loc[row_index, 'group_number'] = group_number
        df.loc[row_index, 'score'] = score

