import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

public class ExcelColumnProcessor {

    public static void main(String[] args) {
        // Path to the Excel file
        String excelFilePath = "input.xlsx";
        String outputFilePath = "output.xlsx";

        try (FileInputStream fis = new FileInputStream(excelFilePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            // Read the first sheet from the Excel file
            Sheet sheet = workbook.getSheetAt(0);

            // Identify columns with headers like "common|doc1", "common|doc2", etc.
            Row headerRow = sheet.getRow(0);
            if (headerRow == null) {
                System.out.println("Header row is missing.");
                return;
            }
            List<Integer> relevantColumns = findRelevantColumns(headerRow);

            // Extend headers with "Common ExactMatch" and "Common Missing"
            int originalColumnCount = headerRow.getLastCellNum();
            List<String> newHeaders = List.of("Common ExactMatch", "Common Missing");
            writeHeader(headerRow, newHeaders);

            // Iterate through all rows starting from the second row (data rows)
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row != null) {
                    // Read only relevant columns
                    String[] values = readRow(row, relevantColumns);

                    // Count ExactMatch and Missing entries
                    long exactMatchCount = Arrays.stream(values)
                            .filter(value -> value.startsWith("ExactMatch"))
                            .count();

                    long missingCount = Arrays.stream(values)
                            .filter(value -> value.startsWith("Missing"))
                            .count();

                    // Write counts back to the row
                    writeRow(row, exactMatchCount, missingCount, originalColumnCount);
                }
            }

            // Write the updated workbook to a new file
            try (FileOutputStream fos = new FileOutputStream(outputFilePath)) {
                workbook.write(fos);
            }

            System.out.println("Processing complete. Updated file written to: " + outputFilePath);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Helper method to identify relevant columns based on headers like "common|docN"
    private static List<Integer> findRelevantColumns(Row headerRow) {
        List<Integer> relevantColumns = new ArrayList<>();
        Pattern pattern = Pattern.compile("common\\|doc\\d+"); // Regex for "common|docN"

        for (int i = 0; i < headerRow.getLastCellNum(); i++) {
            Cell cell = headerRow.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
            String header = cell.toString();
            if (pattern.matcher(header).matches()) {
                relevantColumns.add(i);
            }
        }

        return relevantColumns;
    }

    // Helper method to read values from relevant columns in a row
    private static String[] readRow(Row row, List<Integer> relevantColumns) {
        String[] values = new String[relevantColumns.size()];
        for (int i = 0; i < relevantColumns.size(); i++) {
            int colIndex = relevantColumns.get(i);
            Cell cell = row.getCell(colIndex, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
            values[i] = cell.toString();
        }
        return values;
    }

    // Helper method to write the extended headers
    private static void writeHeader(Row headerRow, List<String> newHeaders) {
        int columnCount = headerRow.getLastCellNum();
        for (int i = 0; i < newHeaders.size(); i++) {
            Cell cell = headerRow.createCell(columnCount + i, CellType.STRING);
            cell.setCellValue(newHeaders.get(i));
        }
    }

    // Helper method to write the ExactMatch and Missing counts to a row
    private static void writeRow(Row row, long exactMatchCount, long missingCount, int originalColumnCount) {
        Cell exactMatchCell = row.createCell(originalColumnCount, CellType.NUMERIC);
        exactMatchCell.setCellValue(exactMatchCount);

        Cell missingCell = row.createCell(originalColumnCount + 1, CellType.NUMERIC);
        missingCell.setCellValue(missingCount);
    }
}
